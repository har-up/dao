# 类加载机制
由与java是在运行时进行加载，连接，初始化，所以java天生具有动态扩展的能力。

## 类型的加载时机
  一个类型从加载到虚拟机至卸载出内存为止，加载、验证、准备、初始化、卸载的顺序是确定的，连接（验证,准备，解析）中的解析则可能会在初始化
  之后才进行（为了支持java语言的运行时绑定特性）。   
  java虚拟机规范规定了6种情况下必须立即对类进行初始化，而在初始化之前的其他步骤的执行时间点并没有强制性约束。
  - 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时
  - 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。
  - 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
  - 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
  - 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为
    REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，
    并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
  - 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，
    那该接口要在其之前被初始化
 
  被动引用不会触发初始化，比如类型数组，调用子类继承自父类的静态变量（不会初始化子类）。引用其他类的常量（由于是常量不会改变，在编译的过程种
  会将其放入自己的常量池中，而不会与常量所在类建立联系）。
  
## 类加载过程
- 加载
  加载是类型加载的一个阶段，该阶段有完成三件事。相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进
  制字节流的动作）是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的引导类加
  载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节
  流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用。
  程序获取运行代码的动态性。
  - 通过类的全限定名获取定义该类的二进制字节流
  - 将二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
  
- 验证
  验证加载的class文件的字节流中包含的信息是否符合规范，且保证其被当成代码运行后损害虚拟机的安全。
  
- 准备
  准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。
  这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
  所以这里所说的初始值“通常情况”下是数据类型的零值。，因为这时尚未开始执行任何Java方法，而把value赋值为123的
  putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。
  
- 解析
  解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。
  
- 初始化
  类的初始化阶段是类加载过程的最后一个步骤，初始化阶段就是执行类构造器<clinit>()方法的过程。之前介绍的几个类加载的动作里，
  除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。
  直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。


## 类和类加载器
  类的唯一性是由加载器和类共同决定的，存在于两个类加载器中的限定名相同的两个类是不同的。
  jdk1.2之后加载器分为三层：
  - 启动类加载器
  - 扩展类加载器
  - 应用程序类加载器
  之后还有自定义加载器。
  那么就可能多个加载器加载了同一个类。为了解决这个问题，设计者把类加载器的加载结构设定为双亲委派模型，就是要加载一个类时首先交与上一层加
  载器去加载，如果上层的都无法加载时，再自己加载。
  
