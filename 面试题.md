## 1.常用的设计模式  
   单例模式、工厂模式、建造者模式、代理模式、装饰模式  
   - 单例模式的实现方法有哪些?  
     饿汉模式、懒汉模式。
     - 二者的区别是?  
      饿汉模式的在定义实例变量的时候就赋值一个单例对象；懒汉模式则在获取实例静态方法中做出判断，如果变量为null,就实例化给变量赋值。
   - 代理模式怎么实现？  
      新建一个类作为代理类，该类持有被代理对象的实例，从而可以访问被代理对象的的熟悉和方法，且可以对其扩展功能。
   
   - 建造者模式怎么实现
      比如A类中声明一个静态内部类Builder。这两个类分别有两个构造器，一个public的无参构造器，一个入另一个类实例的有参构造器。在A类中还需声明一个newBuilder方法返回Builder实例以作修改A类实例属性之用。
       
## 2.进程间通信的几种方法(IPC的几种方式)  
   - Bundle  
      只能传输Bundle支持的数据类型，适用于四大组件不同进程间的通信
   - AIDL  
      最常见的一种进程间通信方式，是首选。任何场景几乎都可以用，但使用稍复杂
   - Messager  
      不能很好的处理高并发情形，不支持RPC,只能传输bundle支持的数据类型。低并发的一对多及时通信可以使用该方式。
   - 使用文件共享
      不适合高并发场景，且无法做到进程间的即时通信。
   - ContentProvider  
      支持一对多并发数据共享
   - Socket  
     功能强大，可以通过网络传输字节流，不过实现细节比较繁琐。
     
## Http和Socket  
   - Http  
     超文本传输协议，对应于应用层，是建立在TCP协议之上的协议。是一种无状态的请求响应式协议，显著的特点是客户端发送的每次请求都需要服务器
     回送相应，在请求结束后，会主动释放连接。一次请求成为需要一次连接。在HTTP1.1版本中加入了长连接，可以在一次连接中发送多次请求。  
     
   - Socket  
     Socket则是对TCP/IP协议的封装和应用,本身并不是一种协议，而是操作通信的接口。Socket是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。  
     建立socket连接至少需要一对套接字，ServerSocket和ClientSocket。其中需要三个过程，服务的监听、客户端请求、连接确认。    
     Socket可以支持不同的传输层协议，TCP/UDP。  
     - TCP连接的三次握手  
       TCP传输层协议建立连接需要进行三次握手。
       1、客户端往服务端发送SYN包，进入SYN_SEND状态，等待服务端响应  
       2、服务端收到请求SYN包，回送SYN+1包和自己的SYN包 SYN+ACK，即，进入SYN_REC状态
       3、客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
       
   - Https和Http
      - http通信使用明文容易被他人窃取数据；https通信内容加密
      - http不验证通讯对方身份，任何请求都接收及响应；https会进行身份验证
      - http无法验证报文的完整性，可能会被篡改；http保证报文完整性
      - https速度相对来说较慢

## 内存泄露
   - 解决内存泄露
      - 注册的回调要在所在对象的生命周期结束时注销，比如对view的监听要在不可见时注销   

   - 怎么排查   
      - 不借用工具的话，可以直接使用AndroidStudio 的Monitor来监测动作变化的内存变化来确定某个操作是否存在内存泄露。   
   
   - 怎么判断一个app在退出后是否内存泄露
      - 在app退出后，点击memory usage生成内存快照查看view和activity的数量是否为0
    
   - 内存泄露的常见情形
      - 在设计单例时传入的是短生命周期的上下文
      - 在Activity中使用非静态内部类，且该内部类有些耗时延时操作，会引用到Activity实例导致其不能被回收。一般用静态来修饰解决问题
      - 不再需要用到的监听未移除。在实现add类的监听时，在Activity关闭时要移除掉该监听   
      - 资源未及时关闭，比如io流、cursor、bitmap、自定义属性attr(recycle()回收)
      - 动画无限循环执行，导致Activity无法被回收   
    
   - 监测工具
     - LeakCanary   一款square公司开发的免费工具
     - Lint   Android Studio中自带的代码检测功能

## 卡顿   
   - 为什么会出现卡顿现象
      - 图像显示需要达到60帧，即每个页面所需渲染时间不超过16ms时就不会卡顿，当低于60帧就会或多或少的可以感受到卡顿。   
        Android主线程负责ui的渲染，若主线程阻塞时就会出现卡顿现象。所以主线程不能执行耗时操作，如io、网络请求等操作； 
        避免频繁GC(频繁GC会出现内存抖动),需要优化程序的内存使用，例如避免一个循环内不断创建对象而频繁触发GC；避免大量运算操作；          
        
   - 怎么分析定位
      - 打开Android Studio的 Android Device Monitor,通过TraceView来定位到问题代码,一般在卡顿的时候，会出现内存抖等情况   
      
        
## 电量相关
   - 怎么电量优化
      工具—— 使用google的开源Battery Historian来监测分析电量消耗情况
      android 5.0及以后的版本可以使用dump来获取电量使用统计数据
      - 开启电量数据收集
       ```java
         $ adb shell dumpsys batterystats --resetBattery stats reset
       ```
      - 收集结束，导出电量收集数据
       ```java
         adb bugreport > [path/]bugreport.zip //android 7.0及以上版本
         adb bugreport > [path/]bugreport.txt //android 5.0/6.0
       ```
      获取到电量收集数据后导入到Battery Historian中，就会生成电量分析图标，可以直观的看到电量的消耗情况。   
      电量消耗最大的主要是硬件唤醒，比如唤醒屏幕时，需要唤醒cpu,gpu等；用到蜂窝数据时唤醒蜂窝设备，这些操作都是极为耗电的。其次，定位也是耗电量较大，尽量避免频繁定位，比如在打开app时执行一次定位操作进行缓存，而不是在需要使用的时候定位。
把一些耗电的操作放到手机充电状态时执行，比如云传输 备份上传等。  
      根据业务情况灵活使用 使用保持屏幕常亮（WAKE_LOCK）, Jobscheduler（把一些不是特别紧急的任务放到更合适的时机批量处理）。   

## HashTable和 HashMap  
   - 都实现了Map接口
   - HashTable继承了Dictionary抽象类、HashMap继承了AbstractMap抽象类
   - HastTable中使用HashtableEntry数组存放数据，put，remove等操作加了synchronized方法（线程安全）且会判断value是否为null,value为null会抛出异常，HashMap中使用Node链表的方式来存放数据，没有加同步锁（非线程安全），key为null时，会强制其hash值为0
   - 抽象方法put(key,value)必须实现，不重写该方法会抛出UnsupportedOperationException异常，put时会先通过hash（key）
   
## Bitmap
   - 怎么回收
      调用bitmap的recycle()方法，彻底一点的话还需要给该对象赋值为null,调用System.gc()方法
      
   - 怎么计算bitmap所占内存
      长*宽*一个像素点所占内存。一般一个像素占4个字节，其中红、绿、蓝、透明度各占一字节， RGB565只占2个字节

   - 加载bitmap
      - decodeResource()
      - decodeFile()
      - decodeStream()  前两个最终都会调用该方法
      
   - 压缩
      - 质量压缩
         原理： 通过算法减小像素质量，减小图片文件大小，但并不能改变bitmap内存占用大小。可以减小图片文件，便于传输。
         ```java
         /**
         * imageType : 图片类型
         * quilty: 压缩质量， 0~100
         * byteArrayOutputStream: 存放压缩后数据的byteArray
         */
         bitmap.compress(imagetype,qulity,byteArrayOutputStream)
         ```
      - 尺寸压缩
         原理： 减少像素，大大的减小图片所占内存。一般用于图片缩略图缓存、头像等
         ```java
         int ratio = 2
         Bitmap targetBitmap = Bitmap.createBitmap(sourceBitmap.width/ratio,sourceBitmap.height/ratio,format); //width、height:要压缩到的尺寸   format:图片每个像素村粗格式 Bitmap.Config.**
         Canvas canvas = new Canvas(targetBitmap);
         Rect rect = new Rect(0,0,sourceBitmap.width/ratio,sourceBitmap.height/ratio);
         canvas.drawBitmap(sourceBitmap,null,rect,null) //画好后图片数据就会存放在targetBitmap中
         ```
      - 采样率压缩
         原理： 通过算法把几个像素点作为一个像素点用，和打码原理类似
         ```java
         private void setPic() {
         // Get the dimensions of the View
         int targetW = mImageView.getWidth();
         int targetH = mImageView.getHeight();

         // Get the dimensions of the bitmap
         BitmapFactory.Options bmOptions = new BitmapFactory.Options();
         bmOptions.inJustDecodeBounds = true;
         BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions);
          int photoW = bmOptions.outWidth;
         int photoH = bmOptions.outHeight;

         // Determine how much to scale down the image
         int scaleFactor = Math.min(photoW/targetW, photoH/targetH);

         // Decode the image file into a Bitmap sized to fill the View
         bmOptions.inJustDecodeBounds = false;
         bmOptions.inSampleSize = scaleFactor;
         bmOptions.inPurgeable = true;

         Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions);
         mImageView.setImageBitmap(bitmap);
         }
         ```
      - 终极压缩
         原理：95年有个jepg处理引擎，05年有个kias处理引擎（jepg处理引擎的二次开发）用于pc端的浏览器，谷歌的android引入了kias处理引擎，但是有阉割，因为其中有个哈夫曼算法比较吃cpu和运存，早期手机硬件跟不上。该终极压缩算法就是加上这被割掉的哈夫曼算法进行压缩。
        
 
## 数据传输效率的优化
   - 使用FlatBuffers
      FlatBuffers在时间和空间上都比Json强很多，直接转化为二进制数据进行传输

## 压缩包优化
   - 图片压缩
      压缩里边的一些资源图片，一些较简单的图片使用svg；压缩成webp图片（加载相对较慢）；
      
   - 资源动态加载      
      图片加载；模块的插件化开发的动态加载
      
   - Lint工具检测
      把一些lint检测出的问题修复优化
      
   - 极限压缩
      7z zip压缩
      
   - proguard 混淆
      其作用：1、删除不用的代码、注释。2、类名和变量名改为较短的字段
