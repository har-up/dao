# 内存管理
## 内存分配
- 本地方法栈帧
  线程私有，和虚拟机栈类似，不过作用的是本地nativie的方法
- 堆内存
  线程共享，存放对象实例数据
- 虚拟机栈
  线程私有，每当执行到一个方法时，就会对应的给这个方法push一个栈帧，栈帧存储的是这个方法的局部变量表，操作数据，方法出口等。方法执行结束  后，对应的
  栈帧会弹出
- 方法区
  线程共享，存放虚拟机加载class文件的类型、常量、静态变量等数据。
- 程序计数器
  线程私有，指向线程要执行的下一个命令
- 运行时常量池
  方法区的一部分，java文件编译成的class文件不仅只包含类型，方法等信息，还有常量池表（用于存放编译期生成的各种字面量和字符引用），运行时常量
  池存放的就是常量池表的内容。
- 直接内存
  jdk1.4引入的NIO可以通过本地Native方法直接在堆外分配内存，在java堆中则可以用DirectByteBuffer对象引用到这些地址进行操作。

## 对象的创建过程
- java虚拟机遇到new命令时，首先回去运行时常量池中检查有不有相应类的符号引用。并检查这个符号引用代表的类是否已经被加载，如果没有则加载对   应类。
- 加载完成后，就可以确定相应的类分配一个对象所需的内存大小了，此时就可以在堆中分配内存，由于堆区是线程共享的，存在数据同步问题，java
  虚拟机使用cas和失败重试的策略来保证操作的原子性。由于对象的内存分配是一个相当频繁的操作，所以为了提升效率，部分虚拟机采用为本地线程   分配缓冲（Thread Local AllocationBuffer，TLAB）的策略
  > 分配内存的过程中有两种情况
  - 指针碰撞
    已分配内存和空闲内存各栈一遍，以指针标记为界限。当需要分配空间时，只需要将指正向空闲空间移动需要分配的大小。
  - 空闲列表
    已分配内存和空闲内存是交替存在的，这时需要一张空闲列表来维护空闲区域。
    
- 分配好内存后，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象哈    希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）

- 此时class文件的<init>()还未执行，所以对象的所以字段都被初始化为0。在new命令执行完毕后，紧接着会执行<init>()方法，按照程序员的意愿   对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

## 对象的内存布局
- 对象头
  - 存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
  - 类型指针，指向该对象所属类型地址，可以通过该指针获取到对象是那个类的实例
- 实例数据
  
- 填充对齐
  占位符，无特殊含义，只是为了对齐。
  
## 对象的访问定位
- 句柄池
  在堆中维护一个句柄池，每个句柄有两个指针，一个指向这个对象的类型数据地址，一个指向这个实例的地址。而对象的引用则是存储的是这个对象的   句柄的地址。
- 直接指针
  引用直接指向对象实例。效率相对句柄池来说教高，但对象的创建是一个很频繁的过程，并且在gc过程中还会移动对象实例的，这时就需要改变引用的   地址，极少成都多就造成了一定的性能损耗。

## OutOfMemoryError异常
- 堆溢出
  提示字样：java.lang.OutOfMemoryError: Java heap space
  先确认造成内存溢出的对象是不是健康存在的，若果是则可以检查虚拟机的堆空间限制参数。
  > 参数
  - 最小值-Xms参数
  - 最大值-Xmx参数
  
- 虚拟机栈和本地方法栈溢出
  提示字样：Exception in thread "main" java.lang.StackOverflowError
  - 栈深度（即栈帧容量）超出限制，容量由不同的虚拟机和操作系统决定
  - 无法申请到足够的内存去存储帧数据时
  > 栈容量参数
  - 指定大小 -Xss （HotSpot指定不能少于228k)
  
- 方法区和运行时常量池
