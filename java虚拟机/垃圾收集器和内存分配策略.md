# 垃圾收集器和内存分配策略
## 垃圾收集器
用于收集“已死”的对象，已死的对象代表不可能再被用到。那么怎么来确定对象“已死”呢？
- 引用计数算法
  在对象中添加一个引用计数器，每当有一个地方用到它时就加1，每当引用失效时就减1，引用计数器为0时则代表可以回收。虽然判断算法简单，效率
  也高，但有一个不足就是无法解决循环引用的问题。java的主流虚拟机也都没有用到这个算法。
- 可达性分析算法
  通过一系列的GC Roots的节点作为起始节点，从这些节点开始向下搜索，搜索过程中走过的路径称为引用链。如果某个对象与GC Roots间没有任何引用链则判断
  为不可达对象，注意此时并不能判断对象已死。
  > 在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：
  - 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
  - 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
  - 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
  - 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
  - Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，
    还有系统类加载器。
  - 所有被同步锁（synchronized关键字）持有的对象。
  - 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
  
## 可达性分析后对象的生死判定
  可达性分析后若判定为不可达对象，此时还不能决定这些对象的生死，相当于“缓刑”阶段。
  > 其中还有两次标记的过程:
  - 在判定为不可达对象时标记一次，之后会有一个筛选的过程（是否有必要执行对象的finalize()）
    没必要的判定执行规则：
    - 没有复写finalize()方法
    - finalize()已经被执行过（对象的finalize()只能被执行一次）
  - 在被判定为不要执行finalize()的对象会被放进一个队列（f-queue)。之后会有一个线程Finalizer去逐个执行对象的finalize()（垃圾回收并不会
    一定等待这个线程执行完毕），若执行finalize()之后对象恢复引用就会把对象移除"即将回收"的集合（这算第二次标记），没有恢复引用的
    对象基本就会被回收了。

## 四种引用
- 强引用
  是指在程序代码之中普遍存在的引用赋值，即类似“Objectobj=new Object()”这种引用关系。无论任何情况下，
  只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用
  述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，
  会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
  在JDK 1.2版之后提供了SoftReference类来实现软引用
- 弱引用
  弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。
  当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。
- 虚引用 
  称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，
  也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。
  在JDK 1.2版之后提供了PhantomReference类来实现虚引用。
