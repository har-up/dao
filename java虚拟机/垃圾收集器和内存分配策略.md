# 垃圾收集器和内存分配策略
## 垃圾收集器
用于收集“已死”的对象，已死的对象代表不可能再被用到。那么怎么来确定对象“已死”呢？
- 引用计数算法
  在对象中添加一个引用计数器，每当有一个地方用到它时就加1，每当引用失效时就减1，引用计数器为0时则代表可以回收。虽然判断算法简单，效率
  也高，但有一个不足就是无法解决循环引用的问题。java的主流虚拟机也都没有用到这个算法。
- 可达性分析算法
  通过一系列的GC Roots的节点作为起始节点，从这些节点开始向下搜索，搜索过程中走过的路径称为引用链。如果某个对象与GC Roots间没有任何引用链则判断
  为不可达对象，注意此时并不能判断对象已死。
  > 在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：
  - 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
  - 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
  - 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
  - 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
  - Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，
    还有系统类加载器。
  - 所有被同步锁（synchronized关键字）持有的对象。
  - 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
  
## 可达性分析后对象的生死判定
  可达性分析后若判定为不可达对象，此时还不能决定这些对象的生死，相当于“缓刑”阶段。
  > 其中还有两次标记的过程:
  - 在判定为不可达对象时标记一次，之后会有一个筛选的过程（是否有必要执行对象的finalize()）
    没必要的判定执行规则：
    - 没有复写finalize()方法
    - finalize()已经被执行过（对象的finalize()只能被执行一次）
  - 在被判定为不要执行finalize()的对象会被放进一个队列（f-queue)。之后会有一个线程Finalizer去逐个执行对象的finalize()（垃圾回收并不会
    一定等待这个线程执行完毕），若执行finalize()之后对象恢复引用就会把对象移除"即将回收"的集合（这算第二次标记），没有恢复引用的
    对象基本就会被回收了。

## 四种引用
- 强引用
  是指在程序代码之中普遍存在的引用赋值，即类似“Objectobj=new Object()”这种引用关系。无论任何情况下，
  只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用
  述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，
  会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
  在JDK 1.2版之后提供了SoftReference类来实现软引用
- 弱引用
  弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。
  当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。
- 虚引用 
  称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，
  也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。
  在JDK 1.2版之后提供了PhantomReference类来实现虚引用。

## 垃圾收集算法
- 分代收集理论
  - 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
  - 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。
  一般分为两块块内存区域，年轻代和老年代。根据理论在年轻代中每次垃圾回收都会有大部分对象被回收，回收后存活的少量对象将逐步晋升到老年代
  存放。分了两个区域那么就有三种不同区域的回收方式。
    - Minor GC (回收年轻代）
    - Major GC（回收年老代）
    - Full GC （都回收）
  还有隔代引用的一种情况（老年代对象引用到年轻代）。为了更正确的回收则需要以老年代中的对象作为GC Root去判定对象的生死存活，这样会影响   到性能，有一种处理方法是给老年代再划分一小块区域存放那些有可能存在跨代引用的对象。
  
- 标记清除算法
  将标记为可回收（或未标记的为可回收）的对象全部清除。
  > 缺点：
  - 回收后会存在大量碎片空间
  - 执行效率不稳定，标记和清除过程随着对象的增多而效率降低
  
- 标记复制
  将可用内存容量分为大小相等的两块，当有一块内存用完后将这块A中回收后存活的对象移至另一块B，然后一次性的清理A中的内存空间，之后先在B中   的内存空间分配，如此往复。
  > 优点： 实现简单，运行高效
  > 缺点： 空间优点浪费
  调查研究发现，基本上新生代的98%对象都不能存活到第二代。所以将内存划分为对等大小的两部分太浪费空间。之后有一种更优化的方法“Apple式回   收”，具体做法是： 将新生代划分为一块较大的Eden空间和两个较小的Survivor空间，每次分配内存都在Eden和其中一块Survivor中，发生垃圾搜   集时，将Eden和Survivor中的存活对象放到另一块Survivor中，然后清理掉Eden和已用过的那块Survivor的空间。HotSpot虚拟机默认的大小是     8:1:1。如果搜集的对象Survivor放不下的话就放入老年代中。
  
- 标记整理算法
  在老年代空间使用，将内存空间分为两块，每次回收就将存活的对象向空间的一端移动，避免碎片内存产生。
