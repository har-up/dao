## 1.常用的设计模式  
   单例模式、工厂模式、建造者模式、代理模式、装饰模式  
   - 单例模式的实现方法有哪些?  
     饿汉模式、懒汉模式。
     - 二者的区别是?  
      饿汉模式的在定义实例变量的时候就赋值一个单例对象；懒汉模式则在获取实例静态方法中做出判断，如果变量为null,就实例化给变量赋值。
   - 代理模式怎么实现？  
      新建一个类作为代理类，该类持有被代理对象的实例，从而可以访问被代理对象的的熟悉和方法，且可以对其扩展功能。
   
   - 建造者模式怎么实现   
      比如A类中声明一个静态内部类Builder。这两个类分别有两个构造器，一个public的无参构造器，一个入另一个类实例的有参构造器。在A类中还需声明一个newBuilder方法返回Builder实例以作修改A类实例属性之用。
       
## 2.进程间通信的几种方法(IPC的几种方式)  
   - Bundle  
      只能传输Bundle支持的数据类型，适用于四大组件不同进程间的通信
   - AIDL  
      最常见的一种进程间通信方式，是首选。任何场景几乎都可以用，但使用稍复杂
   - Messager  
      不能很好的处理高并发情形，不支持RPC,只能传输bundle支持的数据类型。低并发的一对多及时通信可以使用该方式。
   - 使用文件共享
      不适合高并发场景，且无法做到进程间的即时通信。
   - ContentProvider  
      支持一对多并发数据共享
   - Socket  
     功能强大，可以通过网络传输字节流，不过实现细节比较繁琐。
     
## Http和Socket  
   - Http  
     超文本传输协议，对应于应用层，是建立在TCP协议之上的协议。是一种无状态的请求响应式协议，显著的特点是客户端发送的每次请求都需要服务器返回响应，在请求结束后，会主动释放连接。一次请求需要一次连接。在HTTP1.1版本中加入了长连接，可以在一次连接中发送多次请求。  
     
   - Socket  
     Socket则是对TCP/IP协议的封装和应用,本身并不是一种协议，而是操作通信的接口。Socket是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。  
     建立socket连接至少需要一对套接字，ServerSocket和ClientSocket。其中需要三个过程，服务的监听、客户端请求、连接确认。    
     Socket可以支持不同的传输层协议，TCP/UDP。  
     - TCP连接的三次握手  
       TCP传输层协议建立连接需要进行三次握手。
       1、客户端往服务端发送SYN包，进入SYN_SEND状态，等待服务端响应  
       2、服务端收到请求SYN包，回送SYN+1包和自己的SYN包 SYN+ACK，即，进入SYN_REC状态
       3、客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
       
   - Https和Http
      - http通信使用明文容易被他人窃取数据；https通信内容加密
      - http不验证通讯对方身份，任何请求都接收及响应；https会进行身份验证
      - http无法验证报文的完整性，可能会被篡改；http保证报文完整性
      - https速度相对来说较慢

## 内存泄露
   - 解决内存泄露
      - 注册的回调要在所在对象的生命周期结束时注销，比如对view的监听要在不可见时注销   

   - 怎么排查   
      - 不借用工具的话，可以直接使用AndroidStudio 的Monitor来监测动作变化的内存变化来确定某个操作是否存在内存泄露。   
   
   - 怎么判断一个app在退出后是否内存泄露
      - 在app退出后，点击memory usage生成内存快照查看view和activity的数量是否为0
    
   - 内存泄露的常见情形
      - 在设计单例时传入的是短生命周期的上下文
      - 在Activity中使用非静态内部类，且该内部类有些耗时延时操作，会引用到Activity实例导致其不能被回收。一般用静态来修饰解决问题
      - 不再需要用到的监听未移除。在实现add类的监听时，在Activity关闭时要移除掉该监听   
      - 资源未及时关闭，比如io流、cursor、bitmap、自定义属性attr(recycle()回收)
      - 动画无限循环执行，导致Activity无法被回收   
    
   - 监测工具
     - LeakCanary   一款square公司开发的免费工具
     - Lint   Android Studio中自带的代码检测功能

## 卡顿   
   - 为什么会出现卡顿现象
      - 图像显示需要达到60帧，即每个页面所需渲染时间不超过16ms时就不会卡顿，当低于60帧就会或多或少的可以感受到卡顿。   
        Android主线程负责ui的渲染，若主线程阻塞时就会出现卡顿现象。所以主线程不能执行耗时操作，如io、网络请求等操作； 
        避免频繁GC(频繁GC会出现内存抖动),需要优化程序的内存使用，例如避免一个循环内不断创建对象而频繁触发GC；避免大量运算操作；减少过度绘制；          
        
   - 怎么分析定位
      - 打开Android Studio的 Android Device Monitor,通过TraceView来定位到问题代码(比如可以定位到某个耗时的方法),一般在卡顿的时候，会出现内存抖等情况。  
      
        
## 电量相关
   - 怎么电量优化
      工具—— 使用google的开源Battery Historian来监测分析电量消耗情况
      android 5.0及以后的版本可以使用dump来获取电量使用统计数据
      - 开启电量数据收集
       ```java
         $ adb shell dumpsys batterystats --resetBattery stats reset
       ```
      - 收集结束，导出电量收集数据
       ```java
         adb bugreport > [path/]bugreport.zip //android 7.0及以上版本
         adb bugreport > [path/]bugreport.txt //android 5.0/6.0
       ```
      获取到电量收集数据后导入到Battery Historian中，就会生成电量分析图标，可以直观的看到电量的消耗情况。   
      电量消耗最大的主要是硬件唤醒，比如唤醒屏幕时，需要唤醒cpu,gpu等；用到蜂窝数据时唤醒蜂窝设备，这些操作都是极为耗电的。其次，定位也是耗电量较大，尽量避免频繁定位，比如在打开app时执行一次定位操作进行缓存，而不是在需要使用的时候定位。
把一些耗电的操作放到手机充电状态时执行，比如云传输 备份上传等。  
      根据业务情况灵活使用 使用保持屏幕常亮（WAKE_LOCK）, Jobscheduler（把一些不是特别紧急的任务放到更合适的时机批量处理）。   

## HashTable和 HashMap  
   - 都实现了Map接口
   - HashTable继承了Dictionary抽象类、HashMap继承了AbstractMap抽象类
   - HastTable中使用HashtableEntry数组存放数据，put，remove等操作加了synchronized方法（线程安全）且会判断value是否为null,value为null会抛出异常，HashMap中使用Node链表的方式来存放数据，没有加同步锁（非线程安全），key为null时，会强制其hash值为0
   - 抽象方法put(key,value)必须实现，不重写该方法会抛出UnsupportedOperationException异常，put时会先通过hash（key）
   
## HashMap底层原理
   HashMap是基于Hashing的原理。通过put键值对形式存放数据到HashMap中，通过get(key)的方式从HashMap中获取对应的值。当put键值对时，首先会为key生成对应的hashCode（调用key的hashCode（）方法）,通过得到的hashCode找到对应的bucket来存储Entry对象（即键和值作为一个Entry对象存储）。bucket存放的是链表数据，java8中把链表转换成红黑树以加快查找速度。当get（key）查找值时，通过hashCode找到对应的Bucket，如果有多个值（即多个值的hashCode相同）会通过equals来找到相等的key从而找到对应的值。
   
## Bitmap
   - 怎么回收   
      调用bitmap的recycle()方法，彻底一点的话还需要给该对象赋值为null,调用System.gc()方法。
      调用recycle（）方法时，只是回收了bitmap数据的引用，待下一次gc时才能回收真正的图片数据。
      
   - 怎么计算bitmap所占内存   
      长*宽*一个像素点所占内存。一般一个像素占4个字节，其中红、绿、蓝、透明度各占一字节， RGB565只占2个字节
      
   - LruCache   
      一般会使用最近使用算法缓存缓存bitmap，LruCache类是维护了一个泛型的hashmap对象，通过put（）添加缓存对象，通过remove（）移除缓存对象，其中可以重写entryRemove（）自定义移除规则。

   - 加载bitmap   
      - decodeResource()
      - decodeFile()
      - decodeStream()  前两个最终都会调用该方法
      
   - 压缩
      - 质量压缩   
         原理： 通过算法减小像素质量，减小图片文件大小，但并不能改变bitmap内存占用大小。可以减小图片文件，便于传输。
         ```java
         /**
         * imageType : 图片类型
         * quilty: 压缩质量， 0~100
         * byteArrayOutputStream: 存放压缩后数据的byteArray
         */
         bitmap.compress(imagetype,qulity,byteArrayOutputStream)
         ```
      - 尺寸压缩
         原理： 减少像素，大大的减小图片所占内存。一般用于图片缩略图缓存、头像等
         ```java
         int ratio = 2
         Bitmap targetBitmap = Bitmap.createBitmap(sourceBitmap.width/ratio,sourceBitmap.height/ratio,format); //width、height:要压缩到的尺寸   format:图片每个像素村粗格式 Bitmap.Config.**
         Canvas canvas = new Canvas(targetBitmap);
         Rect rect = new Rect(0,0,sourceBitmap.width/ratio,sourceBitmap.height/ratio);
         canvas.drawBitmap(sourceBitmap,null,rect,null) //画好后图片数据就会存放在targetBitmap中
         ```
      - 采样率压缩
         原理： 通过算法把几个像素点作为一个像素点用，和打码原理类似
         ```java
         private void setPic() {
         // Get the dimensions of the View
         int targetW = mImageView.getWidth();
         int targetH = mImageView.getHeight();

         // Get the dimensions of the bitmap
         BitmapFactory.Options bmOptions = new BitmapFactory.Options();
         bmOptions.inJustDecodeBounds = true;
         BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions);
          int photoW = bmOptions.outWidth;
         int photoH = bmOptions.outHeight;

         // Determine how much to scale down the image
         int scaleFactor = Math.min(photoW/targetW, photoH/targetH);

         // Decode the image file into a Bitmap sized to fill the View
         bmOptions.inJustDecodeBounds = false;
         bmOptions.inSampleSize = scaleFactor;
         bmOptions.inPurgeable = true;

         Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions);
         mImageView.setImageBitmap(bitmap);
         }
         ```
      - 终极压缩
         原理：95年有个jepg处理引擎，05年有个kias处理引擎（jepg处理引擎的二次开发）用于pc端的浏览器，谷歌的android引入了kias处理引擎，但是有阉割，因为其中有个哈夫曼算法比较吃cpu和运存，早期手机硬件跟不上。该终极压缩算法就是加上这被割掉的哈夫曼算法进行压缩。
        
 
## 数据传输效率的优化
   - 使用FlatBuffers
      FlatBuffers在时间和空间上都比Json强很多，直接转化为二进制数据进行传输

## 压缩包优化
   - 图片压缩
      压缩里边的一些资源图片，一些较简单的图片使用svg；压缩成webp图片（加载相对较慢）；
      
   - 资源动态加载      
      图片加载；模块的插件化开发的动态加载
      
   - Lint工具检测
      把一些lint检测出的问题修复优化
      
   - 极限压缩
      7z zip压缩
      
   - proguard 混淆
      其作用：1、删除不用的代码、注释。2、类名和变量名改为较短的字段
      
## Service优化
   - 进程优先级分类
      - 前台进程
         用户正在交互的Activity,与正在交互的Activity绑定的service,广播接收器的onReceive()时
      - 可见进程
         处于onPause（），但没有调onStop的Activity，以及绑定到这类Activity的service
      - 服务进程
         startService()启动的服务
      - 后台进程
         与前台相对，对用户操作没有直接影响的进程
      - 空进程
      
   - 进程保活
      - 提升进程优先级方法
         开启一个服务根据锁屏和开屏的广播用一个1像素的Activity来提升进程优先级。
         
      - 双进程守护
      - JobSchedule
        定义一个job不断的去查询保活进程是否还活着，如果保活进程被干掉了就开启保活进程。
      - 监听其他应用的广播
   
   ## 启动优化
      - 测量一个应用的启动时间
         使用以下adb命令，This Time：该Activity启动所需时间； Total Time：整个应用启动所需时间
         ```java
         adb shell am start -W [packageName]/packageName.MainActivity
         ```
      - app启动优化
         - 不要在application，onCreate方法中进行初始化耗时操作
         - 不要在MainActivity的启动生命周期中进行耗时的初始化操作
         - 尽量减少SharedPreference中读取存储次数，减少io操作
      - SplashActivity,SplashFragmet的使用
         在一些必须要初始化一些耗时数据的时候，可以先启动一个SlashActivity，然后跳转到MainActivity。不过这样跳转还会有个MainActivity的初始化过程。
         使用SplashFragment效果更好，当窗体加载完毕的时候通过ViewStub加载真正的主内容，且把SplashFragment移除。
         ```java
         getWindow().getDecorView.post(new Runable({ //窗体加载完毕
         @Override
         public void run(){
            加载内容/移除fragment
         }
         }),seconds)
         ```
         
         
## 基础
   - 四大组件
      - Activity
         Android中一种可以与用户交互的组件。
         scheme跳转：可以通过网页，其他app中进行跳转到app中指定页面。
      - Service
         - 是什么
           一种可以在后台执行长时间运行操作但没有用户交互界面的组件，在主线程中，不能做耗时操作。
         - 与Thread区别
            - 定义不同
               service，是android的一个组件，用于作为后台执行任务的机制。thread,是程序执行的最小单元，是分配cpu资源的基本单位。
            - 使用场景不同
               service运行在主线程，不能处理耗时操作，否则易出现anr现象；Thread是子线程，可以执行耗时操作
      - Broadcast receiver
         一种可以广泛运用于进程间（应用程序间）通信的一种组件，发送的内容是一个intent,intent中可以携带需要传递的数据。
         - 使用场景
            - 同一个app不同进程间的通信
            - 多个不同app间的通信
         - 广播种类
            - 普通广播
            - 有序广播：定义顺序
            - 本地广播：只在app内广播   
         - 实现方式
            - 动态注册
               在代码中注册，其生命周期随activity一样，activity销毁，广播也就销毁了
            - 静态注册
               在manifest中注册，注册完成就一直运行，尽管app进程被杀死都可以接受到广播
         - 内部实现机制
            - 1.自定义广播接收者，重写其onReceive方法
            - 2.通过Binder机制向AMS注册
            - 3.广播发送者通过binder机制向AMS发送广播
            - 4.AMS查找符合条件（IntentFilter/Permission等的筛选）的广播接受者，回调其onReveive（）方法
          
      - Fragment
      
   - Binder
      通常说是一种跨进程通信机制；对于传输过程而言Binder是跨进程通信携带数据的对象；对Serve进程来说Binder指Binder本地对象，对Client而言Binder是代理对象。
       
   - Handler
      Android中一种线程间通信机制，handler可以通过发送和处理Message和Runnable对象来关联相对线程的MessageQueue.
      特点： 可以指定处理message和runnable的时间。子线程处理耗时操作通过handler线程间通信通知主线程更新ui
      - 使用方法
         1、sendMessage()
         2、post（runnable）
      - handler引起的内存泄露及解决办法
         handler内部类持有外部Activity的引用，导致activity无法释放。
         解决：1、把handler改为静态内部类；2、handler内部类持有外部activity的软引用；调用handler.removeCallback()
         
   - AsyncTask
      封装了线程池和Handler的异步框架。
      - 使用
         三个参数（入参、结果、进度）、5个方法（除doInBackGround外都是在主线程执行）
         
   - HandlerThread
      - 是什么   
         handler + thread + looper,本质上是thread,他继承thread但有内部Looper，可以进行looper循环。可以进行处理Android的耗时操作，但是它的效率
         不是很高，因为它是串行执行。
      - 使用   
         通过获取handlerThread的looper对象传递给handler，在handleMessage中处理异步任务。
   - IntentService
      - 是什么   
         继承自Service处理异步任务的一个类，内部有一个工作线程处理耗时操作。
      - 内部机制   
         封装了HandlerThread + Thread。IntentService可以多次start，每次intent都会到onHandleIntent（）进行异步处理。异步操作也是串行执行，一个执行完后才执行下一个。
      - 与Service的区别
         当任务处理完后，会自动销毁
         
## View绘制机制   
   - View树绘制流程
      Measure -> Layout -> Draw
      首先从根布局开始调用View的Measure，Measure里调用onMeasure()遍历子view分别调用子类的getLayoutParam获取宽高数据与自己的测量规格经过一定的算法得到自己的MeasureSpec(widthMeasureSpec和heightMeasureSpec)，然后通过调用setMeasuredDimension（）方法设置属性mMeasuredWidth，mMeasuredHeight。这样层层调用可以为每一个view计算出MeasureSpec。
      Layout过程大致类似，如果继承ViewGroup写自定义View布局，则必须复写其onLayout来指定子View的摆放。
   - invalidate 和 requestLayout的区别    
      invalidata是请求重现绘制，requestLayout是请求重现测量，比如窗口尺寸发生变化，设备切换横竖屏等（不会重新绘制）
        
## 事件分发机制
   - 主要方法的三个方法 
      - dispatTouchEvent
      - onInterceptTouchEvent
         viewGroup才有
      - onTouchEvent
      
   - 事件分发流程
      Activity -> PhoneWindow -> DecorView ->ViewGroup -> ... -> View

## Android内存管理机制
   - 分配机制
      由于移动端内存有限制，在为每个进程分配内存时也会有限制，首先会为每个进程分配少量的内存，在使用过程中不断增加也会为进程开辟额外的内存，但也是有限制的。
   - 回收机制
      当系统发现内存不足时，就会通过杀死优先级低的进程来释放内存。其中还会有效率的计算（杀死一个进程能释放多少内存等）
      
   - Android内存管理机制特点
      - 占用更少的内存
      - 在合适的时候，合理的释放系统资源
      - 在系统内存紧张时，能释放掉大部分不重要的资源
      - 能够在特殊生命周期中，保存或还原重要数据，以至于系统能够重新恢复应用数据。
   - 内存优化
      - Service 任务完成后，尽量停止
      - 在UI不可见时，释放掉只有UI用到的资源
      - 避免使用依赖注入的框架
      
## 冷启动的优化
   - 定义
      冷启动就是在启动应用前，系统中没有该应用的任何进程信息
   - 特点
      冷启动会走Application这个类的启动，热启动不会走Application的生命周期。
   - 冷启动时间的计算
      从创建进程开始计算到页面呈现出来的过程
   - 优化
      - 减少onCreate方法的工作量
      - 不要在Application中做耗时操作
      - 不要在Application中保存静态变量
      - 减少布局复杂性
      
  ## Android架构对比
   - MVC
      - 定义
         模型（Data）'视图(View)'控制器（Activity）
      - 特点
         - 耦合性低
         - 可扩展性好
         - 模块职责划分明确，三层各有所属任务
      
   - MVP
      - 定义
         V: 把Activity做为View层，负责View的绘制以及与用户的交互
         M: 模型（data）
         P: 负责View 与 Model（data）的交互
      - 特点
         将MVC中繁重的Activity进行了抽取，逻辑更清晰。
   - MVVM
      - 定义
         VM: ViewModel 作为中间桥梁负责View 和 Model的交互，与MVP不同的是，View和ViewModel是相互绑定的
         V: 把Activity做为View层，负责View的绘制以及与用户的交互
         M: 模型（data）
      - 特点
         双向绑定
         
## Android 插件化 和 热更新
   主要的两个类
   -DexClassLoader
   -PathClassLoader
   
         
