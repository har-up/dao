# 内存管理
## 内存分配
- 本地方法栈帧
  线程私有，和虚拟机栈类似，不过作用的是本地nativie的方法
- 堆内存
  线程共享，存放对象实例数据
- 虚拟机栈
  线程私有，每当执行到一个方法时，就会对应的给这个方法push一个栈帧，栈帧存储的是这个方法的局部变量表，操作数据，方法出口等。方法执行结束  后，对应的
  栈帧会弹出
- 方法区
  线程共享，存放虚拟机加载class文件的类型、常量、静态变量等数据。
- 程序计数器
  线程私有，指向线程要执行的下一个命令
- 运行时常量池
  方法区的一部分，java文件编译成的class文件不仅只包含类型，方法等信息，还有常量池表（用于存放编译期生成的各种字面量和字符引用），运行时常量
  池存放的就是常量池表的内容。
- 直接内存
  jdk1.4引入的NIO可以通过本地Native方法直接在堆外分配内存，在java堆中则可以用DirectByteBuffer对象引用到这些地址进行操作。

## 对象的创建过程
- java虚拟机遇到new命令时，首先回去运行时常量池中检查有不有相应类的符号引用。并检查这个符号引用代表的类是否已经被加载，如果没有则加载对   应类。
- 加载完成后，就可以确定相应的类分配一个对象所需的内存大小了，此时就可以在堆中分配内存，由于堆区是线程共享的，存在数据同步问题，java
  虚拟机使用cas和失败重试的策略来保证操作的原子性。由于对象的内存分配是一个相当频繁的操作，所以为了提升效率，部分虚拟机采用为本地线程   分配缓冲（Thread Local AllocationBuffer，TLAB）的策略
  > 分配内存的过程中有两种情况
  - 指针碰撞
    已分配内存和空闲内存各栈一遍，以指针标记为界限。当需要分配空间时，只需要将指正向空闲空间移动需要分配的大小。
  - 空闲列表
    已分配内存和空闲内存是交替存在的，这时需要一张空闲列表来维护空闲区域。
    
- 分配好内存后，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象哈    希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）

- 此时class文件的<init>()还未执行，所以对象的所以字段都被初始化为0。在new命令执行完毕后，紧接着会执行<init>()方法，按照程序员的意愿   对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。
