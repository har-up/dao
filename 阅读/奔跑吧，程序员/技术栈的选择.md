## 关于技术栈的考虑
技术栈选择黄金法则：好的技术栈的扩展要快于需要进行的维护
目标是要能够对技术进行扩展——以支持更多用户，更多流量，更多数据和更多代码，通过投入资金和硬件，而不是投入人力来解决问题。
## 技术栈的进化
伟大的公司是进化的结果，而不是天才的设计。
尽管我们喜欢认为技术是严谨计划的结果，但现实情况是大部分技术栈是自然发展的结果，因为我们几乎不能预测未来将面对什么样的技术挑战，而且实现自己不需要的东西
也是一种浪费。因此，唯一可以做的就是先从小型，简单的技术栈开始，并创建一个在必要的时候能够改造技术栈的进程，使之可以适应来自环境中的新压力，比如需要处理
增长的流量，新来的员工，新的功能。更应该关注如何构建可以不断进化的技术栈，而不是太过于关注最佳的技术栈，事实上也不存在最佳的技术栈。

初创公司如何选择初始的技术栈？
熟悉什么就用什么，创业早期我们的目的是尽早的做出用户需要的产品。如果公司顺利生存到下一周期，可以尝试让你的技术栈有所进化，使之满足新的需求。

警惕使用停止一切，彻底重写的做法，暂停所有的发展，在全新的技术栈上重写代码要冒巨大的风险。重写的时候，意味着抛开了
多年的学习和修复的bug，你终将面临许多相同的错误，还要加上新的错误。
我们要选择渐进式的重构
## 内部实现，购买商业产品，还是使用开源产品
### 内部实现
可以对项目完全控制，拥有代码和数据，可以根据自己需要定制项目，根据自己意愿发布新的功能。但需要花费的时间成本高。

### 购买商业产品
即外包项目给专门的软件制作公司，这种方式乙方掌握着代码，无法判断它的质量，无法控制它在未来如何进化。有着巨大的风险，万一外包公司关门歇业了，或者被竞争者收购
了怎么办，还有数据方面的问题。

### 使用开源产品
可以获取开源产品的源代码，并在其基础上实现定制的需求。不利之处在于一些特定的bug，需要在特定的日期发布新版本会和自己项目周期有所冲突。

### 永远不要自己实现的技术
- 安全 加密，密码存储，信用卡存储
- web技术  http服务器，服务器端和客户端框架
- 数据系统：数据库，nosql存储，缓存，消息队列
- 软件分发：版本控制，构建系统，自动化部署
- 计算机科学：基本数据结果（映射，列表，集），排序算法
- 处理通用数据格式的库：xml,html，csv,json,urls
- 实用库：日期/时间操作，字符串操作，日志记录
- 操作系统
- 编程语言

## 选择编程语言
创业公司：熟悉什么就用什么
而后：优化选择

### 编程范式
#### 面向对象编程
尝试将世界万物用对象（封装了数据和行为的数据结构）来建模
c++,java,c#,javascript,ruby,python等
鼓励信息隐藏的方式来减少耦合。
存在两个主要问题：
- 对于“面向对象”真正意味着什么或者怎么做才是正确的没有共识。每一种oop语言和每个程序员的做法都是不一样的。
- 大部分oop都鼓励使用多态和副作用，使得推导、维护、和测试代码变得更加困难。

#### 函数式编程
尝试将世界万物用函数求值来建模。和oop不同，着重限制了可变数据和副作用的使用。函数式编程关注的是将单纯的函数组合起来，使用一种更加
声明式的编程风格去构建复杂的代码，这使得函数式编程更容易推导，维护和进行代码测试。
为啥没有oop流行：函数式编程学习曲线比较陡峭，概念更难入门，函数式代码的性能更加难以预测。

#### 静态类型
静态类型语言能够在编译期捕获到确定的类型错误，比如string 赋给 int类型就会报错。静态类型代码需要被编译，花费时间，降低迭代速度

#### 自动内存管理
c,c++需要程序员手动管理内存的分配和释放。大多数高级语言，java,ruby,python等都支持自动内存管理，可以让程序员关注于所解决的实际问题，
而不是计算机底层的内存架构，可以提升生产效率，又能防止很大一部分bug的出现。不幸的是，自动内存管理也是有代价的。自动释放内存常见的方式
就是垃圾回收，则需要定期运行收集器去扫描所有已分配的内存，对不再使用的内存回收。这就必然会消耗cpu和内存资源
