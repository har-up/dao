## 1.常用的设计模式  
   单例模式、工厂模式、建造者模式、代理模式、装饰模式  
   - 单例模式的实现方法有哪些?  
     饿汉模式、懒汉模式。
     - 二者的区别是?  
      饿汉模式的在定义实例变量的时候就赋值一个单例对象；懒汉模式则在获取实例静态方法中做出判断，如果变量为null,就实例化给变量赋值。
   - 代理模式怎么实现？  
      新建一个类作为代理类，该类持有被代理对象的实例，从而可以访问被代理对象的的熟悉和方法，且可以对其扩展功能。
       
       
## 2.进程间通信的几种方法(IPC的几种方式)  
   - Bundle  
      只能传输Bundle支持的数据类型，适用于四大组件不同进程间的通信
   - AIDL  
      最常见的一种进程间通信方式，是首选。任何场景几乎都可以用，但使用稍复杂
   - Messager  
      不能很好的处理高并发情形，不支持RPC,只能传输bundle支持的数据类型。低并发的一对多及时通信可以使用该方式。
   - 使用文件共享
      不适合高并发场景，且无法做到进程间的即时通信。
   - ContentProvider  
      支持一对多并发数据共享
   - Socket  
     功能强大，可以通过网络传输字节流，不过实现细节比较繁琐。
     
## Http和Socket  
   - Http  
     超文本传输协议，对应于应用层，是建立在TCP协议之上的协议。是一种无状态的请求响应式协议，显著的特点是客户端发送的每次请求都需要服务器
     回送相应，在请求结束后，会主动释放连接。一次请求成为需要一次连接。在HTTP1.1版本中加入了长连接，可以在一次连接中发送多次请求。  
     
   - Socket  
     Socket则是对TCP/IP协议的封装和应用,本身并不是一种协议，而是操作通信的接口。Socket是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。  
     建立socket连接至少需要一对套接字，ServerSocket和ClientSocket。其中需要三个过程，服务的监听、客户端请求、连接确认。    
     Socket可以支持不同的传输层协议，TCP/UDP。  
     - TCP连接的三次握手  
       TCP传输层协议建立连接需要进行三次握手。
       1、客户端往服务端发送SYN包，进入SYN_SEND状态，等待服务端响应  
       2、服务端收到请求SYN包，回送SYN+1包和自己的SYN包 SYN+ACK，即，进入SYN_REC状态
       3、客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

## 内存泄露
   - 解决内存泄露
      - 注册的回调要在所在对象的生命周期结束时注销，比如对view的监听要在不可见时注销   

   - 怎么排查   
      - 不借用工具的话，可以直接使用AndroidStudio 的Monitor来监测动作变化的内存变化来确定某个操作是否存在内存泄露。   
   
   - 怎么判断一个app在退出后是否内存泄露
      - 在app退出后，点击memory usage生成内存快照查看view和activity的数量是否为0
    
   - 内存泄露的常见情形
      - 在设计单例时传入的是短生命周期的上下文
      - 在Activity中使用非静态内部类，且该内部类有些耗时延时操作，会引用到Activity实例导致其不能被回收。一般用静态来修饰解决问题
      - 不再需要用到的监听未移除。在实现add类的监听时，在Activity关闭时要移除掉该监听   
      - 资源未及时关闭，比如io流、cursor、bitmap、自定义属性attr(recycle()回收)
      - 动画无限循环执行，导致Activity无法被回收   
    
   - 监测工具
     - LeakCanary   一款square公司开发的免费工具
     - Lint   Android Studio中自带的代码检测功能

## 卡顿   
   - 为什么会出现卡顿现象
      - 图像显示需要达到60帧，即每个页面所需渲染时间不超过16ms时就不会卡顿，当低于60帧就会或多或少的可以感受到卡顿。   
        Android主线程负责ui的渲染，若主线程阻塞时就会出现卡顿现象。所以主线程不能执行耗时操作，如io、网络请求等操作； 
        避免频繁GC(频繁GC会出现内存抖动),需要优化程序的内存使用，例如避免一个循环内不断创建对象而频繁触发GC；避免大量运算操作；          
        
   - 怎么分析定位
      - 打开Android Studio的 Android Device Monitor,通过TraceView来定位到问题代码,一般在卡顿的时候，会出现内存抖等情况   
      
        
## 电量相关
   - 怎么电量优化
      工具—— 使用google的开源Battery Historian来监测分析电量消耗情况
      android 5.0及以后的版本可以使用dump来获取电量使用统计数据
      - 开启电量数据收集
       ```java
         $ adb shell dumpsys batterystats --resetBattery stats reset
       ```
      - 收集结束，导出电量收集数据
       ```java
         adb bugreport > [path/]bugreport.zip //android 7.0及以上版本
         adb bugreport > [path/]bugreport.txt //android 5.0/6.0
       ```
      获取到电量收集数据后导入到Battery Historian中，就会生成电量分析图标，可以直观的看到电量的消耗情况。   
      电量消耗最大的主要是硬件唤醒，比如唤醒屏幕时，需要唤醒cpu,gpu等；用到蜂窝数据时唤醒蜂窝设备，这些操作都是极为耗电的。其次，定位也是耗电量较大，尽量避免频繁定位，比如在打开app时执行一次定位操作进行缓存，而不是在需要使用的时候定位。
把一些耗电的操作放到手机充电状态时执行，比如云传输 备份上传等。  
      根据业务情况灵活使用 使用保持屏幕常亮（WAKE_LOCK）, Jobscheduler（把一些不是特别紧急的任务放到更合适的时机批量处理）。   

## HashTable和 HashMap   
   - 都实现了Map接口
   - HashTable继承了Dictionary抽象类、HashMap继承了AbstractMap抽象类
   - HastTable中使用HashtableEntry数组存放数据，put，remove等操作加了synchronized方法（线程安全）且会判断value是否为null,value为null会抛出异常，HashMap中使用Node链表的方式来存放数据，没有加同步锁（非线程安全），key为null时，会强制其hash值为0
   - 抽象方法put(key,value)必须实现，不重写该方法会抛出UnsupportedOperationException异常，put时会先通过hash（key）
